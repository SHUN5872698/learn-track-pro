## 指示
Gitのステージングされた変更を分析し、Conventional Commitsガイドラインに基づいた論理的な関心事の塊に分離します。

### 重要な前提
**本プロンプトは Conventional Commits ガイドライン（https://www.conventionalcommits.org）に完全準拠しています。**
**すべての判定基準はConventional Commits公式仕様に基づいています。**

### 最重要ルール
- **必ず `git status -s && git diff --cached && git log -n 10 --pretty=format:'%s%n%b%n---' --no-merges` を実行し、ステージングされた変更内容を正確に把握すること。**
- **変更の意図や背景（特にコード差分から直接読み取れない情報）がある場合は、ユーザーに確認すること。**

### 評価手順

1. **変更内容の分析**: 
   ステージングされたファイル群の変更内容を詳細に分析し、それぞれの変更がどのような目的を持っているかを理解します。

2. **関心事の特定と統合**: 
   - **統合ルール**: 同一ファイルに複数タイプの変更が含まれる場合、最も主要な変更タイプに統合する
   - **分離ルール**: 異なる機能領域に影響する独立した変更は、個別の関心事として分離する
   - **ファイル分割ルール**: 1つのファイルは1つのコミットにのみ含める。同じファイルに複数タイプの変更がある場合、そのファイル全体を最も主要な変更タイプに含める
   - **優先順位**: feat > fix > refactor > perf > style > test > docs > chore

3. **Conventional Commitsタイプの割り当て**: 
   特定した各関心事の塊に対し、Conventional Commitsガイドラインに最も合致するタイプを割り当てます。

4. **出力形式**: 
   以下の形式で、分離された関心事の塊を出力します。

### 統合判定基準

#### ケース1: 同一ファイルに複数の変更タイプ
**1つのファイルは1つのコミットにのみ含める**

例：
- useSectionStatus.jsに新機能追加（feat）とリファクタリング（refactor）が混在
  → **統合**: featとして1つのコミットに（ファイル全体を含める）
  → **理由**: 同じファイルを複数のコミットに分割しない


#### ケース2: 複数ファイルにまたがる一連の変更
**目的が同一の変更は、複数ファイルにまたがっても統合する**

例：
- セクション完了機能の実装が5つのファイルに分散
  → **統合**: 全て`feat`として1つのコミットに

#### ケース3: 独立した関心事
**異なる機能領域への変更は分離する**

例：
- ユーザー管理機能の追加（feat）
- 決済処理のバグ修正（fix）
  → **分離**: 2つの独立したコミットに

#### ケース4: 付随的な変更
**主要な変更に付随する軽微な変更は統合する**

例：
- 新機能追加（feat）に伴うコメント修正（docs）やフォーマット（style）
  → **統合**: `feat`に含める

### 出力形式

```markdown
## 分離された関心事の塊

### 1. [主要なタイプ]: <簡潔なタイトル>
- **タイプ**: <Conventional Commitsタイプ>
- **説明**: <この塊の変更内容の詳細な説明>
- **統合理由**: <複数タイプを統合した場合、その理由>
- **関連ファイル**:
  - <ファイルパス1>
  - <ファイルパス2>
  ...

### 2. [タイプ]: <簡潔なタイトル>
- **タイプ**: <Conventional Commitsタイプ>
- **説明**: <この塊の変更内容の詳細な説明>
- **関連ファイル**:
  - <ファイルパス1>
  ...
```

### キーワード判定基準（Conventional Commits準拠）

#### ユーザー価値への影響
- **feat:** 新機能・機能拡張
  - エンドユーザーにとって新しい機能を提供
  - 既存機能の拡張や改善も含む
  - セマンティックバージョニングのMINOR版を上げる

- **fix:** バグ修正
  - 既存機能の不具合を修正
  - セマンティックバージョニングのPATCH版を上げる

#### コード品質・保守性の改善
- **refactor:** 構造改善（機能変更なし）
  - コードの内部構造を改善
  - 外部の動作に影響しない
  - 可読性・保守性の向上

- **perf:** パフォーマンス改善
  - 既存機能の実行速度・効率を改善
  - ユーザー体験の向上につながる

- **style:** フォーマット・スタイル
  - コードフォーマットの変更
  - 空白、インデント、セミコロンなど
  - 動作に影響しない変更

#### プロジェクト管理・開発環境
- **test:** テスト関連
  - テストの追加・修正・削除
  - テストカバレッジの改善

- **docs:** ドキュメント
  - README、APIドキュメント、コメントなど
  - ドキュメント専用の変更

- **chore:** ビルド・設定・依存関係・保守作業
  - ビルドプロセスの変更
  - 依存関係の更新
  - 設定ファイルの変更
  - 不要ファイルの削除
  - プロジェクトの整理・清掃
  - CI/CDの設定変更
  - **デバッグ用のログ追加**

#### 特別なケース
- **type!:** 破壊的変更（!を付加）
  - APIの変更でバックワード互換性が失われる
  - セマンティックバージョニングのMAJOR版を上げる
- **revert:** コミットの取り消し
  - 過去のコミットを取り消す場合

### 重要な判定ポイント

1. **主要な変更タイプを優先**
   - 複数のタイプが混在する場合、最も重要な変更タイプに統合
   - 優先順位: feat > fix > refactor > perf > style > test > docs > chore

2. **関連性の高い変更は統合**
   - 同一機能に関する変更は1つのコミットに
   - 付随的な変更（コメント、フォーマット）は主要な変更に含める

3. **独立した機能領域は分離**
   - 異なる機能モジュール間の変更は分離
   - 異なるビジネスロジックへの変更は分離

4. **ファイル削除は `chore` が適切**
   - 不要になったファイルの削除
   - プロジェクトの整理・清掃作業
   - 一時的なファイルの削除

## 最終アクション

すべての評価が完了したら、分離された関心事の塊を上記の出力形式で**直ちに出力してください。**

- 出力先ファイル: [.gemini/outputs/separated-concerns.md](../outputs/separated-concerns.md)

**重要**:
- このタスクは、ファイルへの出力をもって完全に完了します。
- コミットメッセージの生成や、コミットを提案するような追加のアクションは一切行わないでください。
- 出力後、必ず`.gitignore`や`.geminiignore`、`.git/info/exclude`の設定を無視して出力先ファイルを読み込み、内容が正しく書き込まれていることを確認してください。
  - `read_many_files`ツールを使用し、`file_filtering_options={"respect_gemini_ignore": False, "respect_git_ignore": False}`を指定すること
- 確認が取れたら「ファイルに出力しました」と報告して終了
